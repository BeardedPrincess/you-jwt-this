# README: You JWT This!
This project is used to demonstrate basic asymmetric cryptography operations, specifically to verify that a holder has possession of a private key.  This kind of verification is most often used during authentication scenarios like OAUTH flows. To help make this connection a bit more clear, the solution uses a payload formatted as a JWT-token which is utilized frequently with OAUTH2/OIDC authentication.

This solution also implements a simple *nonce* generation and validation. A *nonce* is used to prevent replay attacks, i.e. allowing someone to steal and reuse your JWT token.  By effectively using a *nonce*, the JWT token becomes a one-time-use token.  In this example, the *nonce* is requested by `holder` from the `verifier` service itself. The `verifier` service can then keep a list of *nonce* values it's handed out, make sure they're only used one time, and even expire them after a period of time.

## Overview
The sample solution consists of two binaries: `holder` and `verifier`.

### Holder Operations
After requesting a new *nonce* from the `verfier` service, `holder` will create a data payload which includes its public-key (as a `jwk` claim) as well as the *nonce* it got from `verifier`. There's other information in the payload too, but it's mostly just placeholder text for now.  Once the payload is created, `holder` adds a properly formatted JWT header, and then encodes everything as a single URLEncoded Base64 string. (This just makes it easier to transfer the data over HTTP by making even complex / non-printable bytes into normal text!)

Finally, `holder` will create a signature of this string by using a private-key, specifically the private-key that corresponds to the public-key in the payload.  This signature, which is technically 32-bytes of mostly machine-readable characters, also gets the URLEncoded Base64 treatment, and is added to the payload.

> NOTE:  If holder doesn't have a private key already, it will generate one, and save it to a file named `keyfile.jwk` in your current directory.  You can choose another file by setting an environment variable before running the holder application (details below).

When these operations are complete, the payload and bundle are sent (via an HTTP request) to the `verifier`, to be validated.

### Verifier Operations
When the `verifier` service receives the request from the `holder`, it will first "unwrap" the payload, header, and signature from the HTTP request and make sure that the data is matches the expected format.  It will extract the holder's public key, as well as the *nonce* from the JWT payload, and then use the supplied public-key to validate the signature.  This validation process cryptographically proves that whoever created the signature has to have access to the private-key, because it's the only cryptographic way to get the valid signature.

In addition to validating the signature, the *nonce* is also validated, ensuring that it was generated by the `verifier`, hasn't been too long since the *nonce* was registered (within a minute), and that it hasn't been used before.

If it all checks out, the payload will be validated successfully.  This is a very effective method of proving that a client has access to the private key associated with some public key.

# Try it out!
Executable binaries have been provided for a wide variety of different platforms and operating systems (Linux / Windows / MacOS) and for Intel/AMD 64-bit as well as ARM 64-bit architectures.  Be sure to use the right binary for your operating system and architecture!

## Start the verifier service
Make sure you're in the right sub-directory of `dist/` for your operating system, and then start the verifier web-service by running the following command:

```bash
./verifier
```

You should see some output similar to the following, and take note, the `verifier` service will stay running until stopped - or it catches a nasty error :/.  You can hit `Ctrl-C` to stop it anytime.

```
2025/11/29 14:15:35 [INFO] Using default listener address at 127.0.0.1:8080.
```

> #### NOTE:
> If you need to choose a different port to listen on, you can modify the default port by setting the environment variable while starting verifier:
> ```
>    YJT_ADDR=":8888" ./verifier
> ```
> This command will cause `verifier` to listen on ALL IPs, at port 8888.

## Execute the holder
In another terminal window or tab, run the `holder` binary using this command:

```bash
./holder
```

If you modified your `verifier`'s listener port or IP address, you may need to include the `YJT_ADDR` variable again:

```
  YJT_ADDR="192.168.0.10:8888" ./holder
```

This command will tell the holder to connect to the verifier running at IP 192.168.0.10 on port 8888. This allows you to these on different systems if you need, but the default should work easily for most systems, without having to worry about networking.

### So, what happened?
You should see some output that looks like the following, in the terminal window where you executed the `holder` application:

```
------- Response from verifier service at 127.0.0.1:8080: -----------
{"ok":true,"message":"Valid signature and nonce: Private Key Holder Verified"}
```

If you see this, you have successfully run the demo!

### Wait, I never learn from something that works the first time!
Let's try and break the signature validation, on purpose.  Here's something to try:

Let's run `holder` a couple of times, each time creating a new key file.  You may have noticed that the first time it ran, it created a file to store the key it generated since you didn't have one already. We're going to specify a couple of new files to create explicitly:

```
YJT_KEYFILE="one.jwk" ./holder
# ... and again
YJT_KEYFILE="two.jwk" ./holder

# Show our work:
ls -l *.jwk
```

You'll probably see two or three files: `one.jwk`, `two.jwk`, and `keyfile.jwk`.

Open `one.jwk` in a text editor, it should look something like this:

```
{"kty":"OKP","crv":"Ed25519","x":"-Pet4eQfSK4egl2jZIIbNAoZxi7bxEVajDz6a7rgn8E","d":"_mADdteumCAlSBE8Pqf7RET3_GLkfUNXFdQg6JEXYwn4963h5B9Irh6CXaNkghs0ChnGLtvERVqMPPpruuCfwQ"}
```

This is your public and private key in a `JSON web key format` or a `JWK`.  The `x` value holds the public key, and the `d` value holds the private key.

Open up `two.jwk` in another editor window, copy the private key from `one.jwk` (in this sample, that is the text `_mADdteumCAlSBE8Pqf7RET3_GLkfUNXFdQg6JEXYwn4963h5B9Irh6CXaNkghs0ChnGLtvERVqMPPpruuCfwQ`) and replace the private key (`d`) value in `two.jwk`.  Save your changes, and run the following command (again):

```
YJT_KEYFILE="two.jwk" ./holder
```

This time, you should see another message, `signature invalid`. Why? Because the public key and private key no longer match!


# What's next?
You can check out the source code for this project at https://github.com/beardedprincess/you-jwt-this.  Feel free to poke around, even change things, or make it better!

> # IMPORTANT!
> This sample application is nowhere near ready for production use!  It is a simple demo only, and at that, I would do things a bit differently if I had more time!

### Things to do better

- The collection of functions in internal/crypto/ed25519.go should be turned into a Go interface, so that it's much easier and cleaner to drop in new kinds of algorithms, or even cryptographic service providers (like and HSM or smartcard).
- The *nonce* tracking in the `verifier` service is very simple.  It may quickly run into problems if trying to handle multiple simultaneous requests because it makes no attempts at "locking" the set of records. This could be done easily with a mutex (IYKYK), but the entire nonce tracking should be done external to binary anyway!
- This doesn't scale: primarily because of the nonce tracking (see above).. ideally one would use an external shared storage for he nonces so that multiple copies of verifier could run behind a load-balancer
- Nonces never get cleaned up.. this is essentially a memory leaking situation.. if left running for a long time, and with a lot of connections, `verifier` could use up all the RAM and stop working. (also a problem from a denial-of-service perspective!)

- Besides the signature and nonce, `verifier` doesn't really verify much else!  Best practices for JWT would include validating the `aud` attribute at least, and probably the `iat` / `exp` claims too (issued at and expire on).
- In most implementations using JWT, the public key isn't even sent with the payload, but rather a URL/hostname of a trusted issuer, where the verifier can download a JWK from a verifiable (trusted) source. This is a bit more self-contained, but identity security comes down to **trust**, and this implementation really has none of that!
